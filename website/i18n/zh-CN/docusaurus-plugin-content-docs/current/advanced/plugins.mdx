---
title: 插件
sidebar_label: 插件
---

# 插件

插件是 Docusaurus 网站中功能的构建块。每个插件都处理其自己的独立功能。插件可以通过 preset 作为捆绑包的一部分工作和分发。

## 创建插件 {#creating-plugins}

插件是一个接收两个参数的函数：`context` 和 `options`。它返回一个插件实例对象（或一个 promise）。你可以将插件创建为函数或模块。更多信息，请参阅 [plugin 方法参考章节](../api/plugin-methods/README.mdx)。

### 函数定义 {#function-definition}

你可以直接在 Docusaurus 配置文件中将插件用作一个函数：

```js title="docusaurus.config.js"
export default {
  // ...
  plugins: [
    // highlight-start
    async function myPlugin(context, options) {
      // ...
      return {
        name: 'my-plugin',
        async loadContent() {
          // ...
        },
        async contentLoaded({content, actions}) {
          // ...
        },
        /* 其他生命周期 API */
      };
    },
    // highlight-end
  ],
};
```

### 模块定义 {#module-definition}

你可以将插件用作一个引用了单独文件或 npm 包的模块路径：

```js title="docusaurus.config.js"
export default {
  // ...
  plugins: [
    // 无选项：
    './my-plugin',
    // 或有选项：
    ['./my-plugin', options],
  ],
};
```

然后在 `my-plugin` 文件夹中，你可以创建一个像下面这样的 `index.js`：

```js title="my-plugin/index.js"
export default async function myPlugin(context, options) {
  // ...
  return {
    name: 'my-plugin',
    async loadContent() {
      /* ... */
    },
    async contentLoaded({content, actions}) {
      /* ... */
    },
    /* 其他生命周期 API */
  };
}
```

---

你可以使用[调试插件的元数据面板](/__docusaurus/debug/metadata)查看你网站中安装的所有插件。

插件有几种类型：

- `package`: 你安装的外部包
- `project`: 你在项目中创建的插件，以本地文件路径的形式提供给 Docusaurus
- `local`: 使用函数定义创建的插件
- `synthetic`: Docusaurus 内部创建的“假插件”，以便我们利用模块化架构，不让核心做太多特殊工作。你不会在元数据中看到它，因为这是一个实现细节。

你可以在客户端通过 `useDocusaurusContext().siteMetadata.pluginVersions` 访问它们。

## 插件设计 {#plugin-design}

Docusaurus 对插件系统的实现为我们提供了一种便捷的方式来挂接到网站的生命周期中，以修改开发/构建期间发生的事情，这包括（但不限于）扩展 webpack 配置、修改加载的数据以及创建要在页面中使用的新组件。

### 主题设计 {#theme-design}

当插件加载了其内容后，数据通过像 [`createData` + `addRoute`](../api/plugin-methods/lifecycle-apis.mdx#addRoute) 或 [`setGlobalData`](../api/plugin-methods/lifecycle-apis.mdx#setGlobalData) 这样的操作提供给客户端。这些数据必须被_序列化_为纯字符串，因为[插件和主题在不同的环境中运行](./architecture.mdx)。一旦数据到达客户端，剩下的部分对于 React 开发者来说就很熟悉了：数据在组件之间传递，组件由 Webpack 打包，并通过 `ReactDOM.render` 渲染到窗口中……

**主题提供用于渲染内容的 UI 组件集。** 大多数内容插件需要与主题配对才能真正发挥作用。UI 是与数据模式分离的独立层，这使得更换设计变得容易。

例如，一个 Docusaurus 博客可能由一个博客插件和一个博客主题组成。

:::note

这是一个刻意设计的例子：在实践中，`@docusaurus/theme-classic` 为文档、博客和布局提供了主题。

:::

```js title="docusaurus.config.js"
export default {
  // highlight-next-line
  themes: ['theme-blog'],
  plugins: ['plugin-content-blog'],
};
```

如果你想使用 Bootstrap 样式，你可以用 `theme-blog-bootstrap`（另一个虚构的不存在的主题）替换掉该主题：

```js title="docusaurus.config.js"
export default {
  // highlight-next-line
  themes: ['theme-blog-bootstrap'],
  plugins: ['plugin-content-blog'],
};
```

现在，虽然主题从插件接收到相同的数据，但主题选择如何将数据_渲染_为 UI 的方式可能会有很大不同。

虽然主题与插件共享完全相同的生命周期方法，但基于主题的设计目标，主题的实现可能与插件的实现看起来非常不同。

主题旨在完成 Docusaurus 网站的构建，并提供你的网站、插件和主题本身所使用的组件。一个主题仍然像一个插件一样行事，并暴露一些生命周期方法，但它们很可能不会使用 [`loadContent`](../api/plugin-methods/lifecycle-apis.mdx#loadContent)，因为它们只从插件接收数据，而不自己生成数据；主题通常还附带一个充满了组件的 `src/theme` 目录，这些组件通过 [`getThemePath`](../api/plugin-methods/extend-infrastructure.mdx#getThemePath) 生命周期告知核心。

总结一下：

- 主题与插件共享相同的生命周期方法
- 主题在所有现有插件之后运行
- 主题通过提供 `getThemePath` 来添加组件别名。
