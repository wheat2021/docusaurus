---
slug: /versioning
---

# 版本控制

您可以使用版本控制 CLI 根据 `docs` 目录中的最新内容创建一个新的文档版本。然后，这套特定的文档将被保存并可访问，即使 `docs` 目录中的文档继续演进。

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

:::warning

在开始对您的文档进行版本控制之前请三思——这可能会让贡献者难以帮助改进它！

:::

大多数时候，您不需要版本控制，因为它只会增加您的构建时间，并给您的代码库带来复杂性。版本控制**最适合于流量大且版本之间文档变化迅速的网站**。如果您的文档很少更改，请不要为您的文档添加版本控制。

要更好地理解版本控制的工作原理并看它是否适合您的需求，您可以继续阅读下文。

## 概述 {#overview}

一个典型的版本化文档站点如下所示：

```bash
website
├── sidebars.json        # 当前文档版本的侧边栏
├── docs                 # 当前文档版本的 docs 目录
│   ├── foo
│   │   └── bar.md       # https://mysite.com/docs/next/foo/bar
│   └── hello.md         # https://mysite.com/docs/next/hello
├── versions.json        # 指示可用版本的文件
├── versioned_docs
│   ├── version-1.1.0
│   │   ├── foo
│   │   │   └── bar.md   # https://mysite.com/docs/foo/bar
│   │   └── hello.md
│   └── version-1.0.0
│       ├── foo
│       │   └── bar.md   # https://mysite.com/docs/1.0.0/foo/bar
│       └── hello.md
├── versioned_sidebars
│   ├── version-1.1.0-sidebars.json
│   └── version-1.0.0-sidebars.json
├── docusaurus.config.js
└── package.json
```

`versions.json` 文件是一个版本名称列表，从新到旧排序。

下表解释了版本化文件如何映射到其版本和生成的 URL。

| 路径                                    | 版本        | URL               |
| --------------------------------------- | -------------- | ----------------- |
| `versioned_docs/version-1.0.0/hello.md` | 1.0.0          | /docs/1.0.0/hello |
| `versioned_docs/version-1.1.0/hello.md` | 1.1.0 (最新) | /docs/hello       |
| `docs/hello.md`                         | 当前        | /docs/next/hello  |

:::tip

`docs` 目录中的文件属于 `current` 文档版本。

默认情况下，`current` 文档版本被标记为 `Next` 并托管在 `/docs/next/*` 下，但可以完全配置以适应您项目的发布生命周期。

:::

### 术语 {#terminology}

请注意我们在这里使用的术语。

<dl>
  <dt>
    <b>当前版本</b>
  </dt>
  <dd>
    {'放置在 '}
    <code>./docs</code>
    {' 文件夹中的版本。'}
  </dd>
  <dt>
    <b>最新版本 / 最后版本</b>
  </dt>
  <dd>
    {'文档导航栏项目默认服务的版本。通常路径为 '}
    <code>/docs</code>
    {'.'}
  </dd>
</dl>

当前版本由**文件系统位置**定义，而最新版本由**导航行为**定义。它们可能相同也可能不同！（默认配置，如上表所示，将它们视为不同：当前版本在 `/docs/next`，最新版本在 `/docs`。）

## 教程 {#tutorials}

### 标记新版本 {#tagging-a-new-version}

1. 首先，确保当前的文档版本（`./docs` 目录）已准备好被冻结。
2. 输入一个新的版本号。

```bash npm2yarn
npm run docusaurus docs:version 1.1.0
```

标记新版本时，文档版本控制机制将：

- 将 `docs/` 文件夹的全部内容复制到一个新的 `versioned_docs/version-[versionName]/` 文件夹中。
- 根据您当前的[侧边栏](./sidebar/index.mdx)配置创建一个版本化的侧边栏文件（如果存在）——保存为 `versioned_sidebars/version-[versionName]-sidebars.json`。
- 将新的版本号附加到 `versions.json`。

### 创建新文档 {#creating-new-docs}

1. 将新文件放入相应的版本文件夹中。
2. 根据版本号，在相应的侧边栏文件中包含对新文件的引用。

```mdx-code-block
<Tabs>
<TabItem value="当前版本结构">
```

```bash
# 新文件。
docs/new.md

# 编辑相应的侧边栏文件。
sidebars.js
```

```mdx-code-block
</TabItem>
<TabItem value="旧版本结构">
```

```bash
# 新文件。
versioned_docs/version-1.0.0/new.md

# 编辑相应的侧边栏文件。
versioned_sidebars/version-1.0.0-sidebars.json
```

```mdx-code-block
</TabItem>
</Tabs>
```

:::tip

版本化的侧边栏文件，与标准侧边栏文件一样，是相对于给定版本的内容根目录的——因此对于上面的例子，您的版本化侧边栏文件可能看起来像：

```json
{
  "sidebar": [
    {
      "type": "autogenerated",
      "dirName": "."
    }
  ]
}
```

或者对于手动侧边栏：

```json
{
  "sidebar": [
    {
      "type": "doc",
      "id": "new",
      "label": "新"
    }
  ]
}
```

:::

### 更新现有版本 {#updating-an-existing-version}

您可以同时更新多个文档版本，因为 `versioned_docs/` 中的每个目录在发布时都代表特定的路由。

1. 编辑任何文件。
2. 提交并推送更改。
3. 它将被发布到该版本。

例如：当您更改 `versioned_docs/version-2.6/` 中的任何文件时，它将只影响 `2.6` 版本的文档。

### 删除现有版本 {#deleting-an-existing-version}

您也可以删除/移除版本。

1. 从 `versions.json` 中移除版本。

例如：

```diff
[
  "2.0.0",
  "1.9.0",
  // highlight-next-line
- "1.8.0"
]
```

2. 删除版本化的文档目录。例如：`versioned_docs/version-1.8.0`。
3. 删除版本化的侧边栏文件。例如：`versioned_sidebars/version-1.8.0-sidebars.json`。

## 配置版本控制行为 {#configuring-versioning-behavior}

“当前”版本是 `./docs` 文件夹的版本名称。有不同的方式来管理版本控制，但两种非常常见的模式是：

- 您发布了 v1，并立即开始开发 v2（包括其文档）。在这种情况下，**当前版本**是 v2，它位于 `./docs` 源文件夹中，可以在 `example.com/docs/next` 浏览。**最新版本**是 v1，它位于 `./versioned_docs/version-1` 源文件夹中，大多数用户在 `example.com/docs` 浏览。
- 您发布了 v1，并将在考虑 v2 之前维护它一段时间。在这种情况下，**当前版本**和**最新版本**都将指向 v1，因为 v2 文档甚至还不存在！

Docusaurus 的默认设置非常适合第一种用例。我们将当前版本标记为“next”，您甚至可以选择不发布它。

**对于第二种用例**：如果您发布了 v1 并且不打算很快开始开发 v2，与其对 v1 进行版本控制并不得不在 2 个文件夹（`./docs` + `./versioned_docs/version-1.0.0`）中维护文档，您可以考虑通过给当前版本一个路径和标签来“假装”它是一个已发布的版本：

```js title="docusaurus.config.js"
export default {
  presets: [
    '@docusaurus/preset-classic',
    docs: {
      // highlight-start
      lastVersion: 'current',
      versions: {
        current: {
          label: '1.0.0',
          path: '1.0.0',
        },
      },
      // highlight-end
    },
  ],
};
```

`./docs` 中的文档将在 `/docs/1.0.0` 而不是 `/docs/next` 提供服务，`1.0.0` 将成为我们在导航栏下拉菜单中链接到的默认版本，您将只需要维护一个 `./docs` 文件夹。

我们提供这些插件选项来自定义版本控制行为：

- `disableVersioning`：即使有版本也明确禁用版本控制。这将使站点只包含当前版本。
- `includeCurrentVersion`：包含您文档的当前版本（`./docs` 文件夹）。
  - **提示**：如果当前版本是正在进行中的工作，尚未准备好发布，请将其关闭。
- `lastVersion`：设置“最新版本”（`/docs` 路由）指向哪个版本。
  - **提示**：如果您的当前版本指向一个不断打补丁和发布的主版本，`lastVersion: 'current'` 是有意义的。最新版本的实际路由基路径和标签是可配置的。
- `onlyIncludeVersions`：定义要部署的 `versions.json` 中的版本子集。
  - **提示**：在开发和部署预览中限制为 2 或 3 个版本，以提高启动和构建时间。
- `versions`：版本元数据的字典。对于每个版本，您可以自定义以下内容：
  - `label`：在版本下拉菜单和横幅中显示的标签。
  - `path`：此版本的路由基路径。默认情况下，最新版本为 `/`，当前版本为 `/next`。
  - `banner`：`'none'`、`'unreleased'` 和 `'unmaintained'` 之一。决定在每个文档页面顶部显示什么。任何高于最新版本的版本都将是“未发布”，任何低于最新版本的版本都将是“未维护”。
  - `badge`：在该版本的文档顶部显示一个带有版本名称的徽章。
  - `className`：为该版本的文档页面的 `<html>` 元素添加一个自定义的 `className`。

有关更多详细信息，请参阅[文档插件配置](../../api/plugins/plugin-content-docs.mdx#configuration)。

## 导航栏项目 {#navbar-items}

我们提供几种文档导航栏项目，以帮助您快速设置导航，而无需担心版本化的路由。

- [`doc`](../../api/themes/theme-configuration.mdx#navbar-doc-link)：指向一个文档的链接。
- [`docSidebar`](../../api/themes/theme-configuration.mdx#navbar-doc-sidebar)：指向侧边栏中第一项的链接。
- [`docsVersion`](../../api/themes/theme-configuration.mdx#navbar-docs-version)：指向当前查看版本的主文档的链接。
- [`docsVersionDropdown`](../../api/themes/theme-configuration.mdx#navbar-docs-version-dropdown)：一个包含所有可用版本的下拉菜单。

这些链接都会按以下顺序查找要链接到的适当版本：

1. **活动版本**：用户当前正在浏览的版本，如果她在一个由该文档插件提供的页面上。如果她不在文档页面上，则回退到...
2. **首选版本**：用户上次查看的版本。如果没有历史记录，则回退到...
3. **最新版本**：我们导航到的默认版本，由 `lastVersion` 选项配置。

## `docsVersionDropdown` {#docsVersionDropdown}

默认情况下，[`docsVersionDropdown`](../../api/themes/theme-configuration.mdx#navbar-docs-version-dropdown) 显示一个包含所有可用文档版本的下拉菜单。

`versions` 属性允许您按给定顺序显示可用文档版本的子集：

```js title="docusaurus.config.js"
export default {
  themeConfig: {
    navbar: {
      items: [
        {
          type: 'docsVersionDropdown',
          // highlight-start
          versions: ['current', '3.0', '2.0'],
          // highlight-end
        },
      ],
    },
  },
};
```

传递一个 `versions` 对象，可以让您覆盖每个版本的显示标签：

```js title="docusaurus.config.js"
export default {
  themeConfig: {
    navbar: {
      items: [
        {
          type: 'docsVersionDropdown',
          // highlight-start
          versions: {
            current: {label: '版本 4.0'},
            '3.0': {label: '版本 3.0'},
            '2.0': {label: '版本 2.0'},
          },
          // highlight-end
        },
      ],
    },
  },
};
```

## 推荐做法 {#recommended-practices}

### 仅在需要时对您的文档进行版本控制 {#version-your-documentation-only-when-needed}

例如，您正在为您的 npm 包 `foo` 构建文档，当前版本为 1.0.0。然后您为一个次要的错误修复发布了一个补丁版本，现在是 1.0.1。

您应该为它创建一个新的文档版本 1.0.1 吗？**您可能不应该**。根据 semver，1.0.1 和 1.0.0 的文档不应该有区别，因为没有新功能！为它创建一个新版本只会产生不必要的重复文件。

### 保持版本数量少 {#keep-the-number-of-versions-small}

一个好的经验法则是，尽量将您的版本数量保持在 10 个以下。您**很可能**会有很多过时的版本化文档，甚至没有人再阅读了。例如，[Jest](https://jestjs.io/versions) 目前是 `27.4` 版本，只维护了几个最新的文档版本，最低的是 `25.X`。保持数量少 😊

:::tip 归档旧版本

如果您将您的站点部署在 Jamstack 提供商（例如 [Netlify](../../deployment.mdx)）上，该提供商会将每个生产构建保存为快照，并提供一个不可变的 URL。您可以将永远不会重新构建的已归档版本作为外部链接包含到这些不可变的 URL 中。Jest 网站和 Docusaurus 网站都使用这种模式来保持活跃构建的版本数量少。

:::

### 在文档中使用绝对导入 {#use-absolute-import-within-the-docs}

不要在文档中使用相对路径导入。因为当我们创建一个版本时，路径就不再有效了（嵌套级别不同，等等）。您可以使用 Docusaurus 提供的指向 `website` 目录的 `@site` 别名。例如：

```diff
- import Foo from '../src/components/Foo';
+ import Foo from '@site/src/components/Foo';
```

### 按文件路径链接文档 {#link-docs-by-file-paths}

通过带有 `.md` 扩展名的相对文件路径来引用其他文档，以便 Docusaurus 在构建期间可以将它们重写为实际的 URL 路径。文件将被链接到正确的相应版本。

```md
[@hello](hello.mdx#paginate) 文档很棒！

有关更多信息，请参阅[教程](../getting-started/tutorial.mdx)。
```

### 全局或版本化的共置资源 {#global-or-versioned-collocated-assets}

您应该决定像图片和文件这样的资源是每个版本独有的还是在版本之间共享的。

如果您的资源应该被版本化，请将它们放在文档版本中，并使用相对路径：

```md
![图片 alt](./myImage.png)

[下载此文件](./file.pdf)
```

如果您的资源是全局的，请将它们放在 `/static` 中并使用绝对路径：

```md
![图片 alt](/myImage.png)

[下载此文件](/file.pdf)
```
