---
slug: /sidebar/autogenerated
---

# 自动生成

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

Docusaurus 可以根据您的**文件系统结构自动创建一个侧边栏**：每个文件夹创建一个侧边栏分类，每个文件创建一个文档链接。

```ts
type SidebarItemAutogenerated = {
  type: 'autogenerated';
  dirName: string; // 用于生成侧边栏切片的源文件夹（相对于 docs）
};
```

Docusaurus 可以从您的 docs 文件夹生成一个完整的侧边栏：

```js title="sidebars.js"
export default {
  myAutogeneratedSidebar: [
    // highlight-start
    {
      type: 'autogenerated',
      dirName: '.', // '.' 表示当前的 docs 文件夹
    },
    // highlight-end
  ],
};
```

一个 `autogenerated` 项目被 Docusaurus 转换为一个**侧边栏切片**（在[分类简写](items.mdx#category-shorthand)中也有讨论）：一个类型为 `doc` 或 `category` 的项目列表，因此您可以在一个侧边栏级别中，将来自多个目录的**多个 `autogenerated` 项目**与常规侧边栏项目交错拼接。

<details>
<summary>一个真实世界的例子</summary>

考虑这个文件结构：

```bash
docs
├── api
│   ├── product1-api
│   │   └── api.md
│   └── product2-api
│       ├── basic-api.md
│       └── pro-api.md
├── intro.md
└── tutorials
    ├── advanced
    │   ├── advanced1.md
    │   ├── advanced2.md
    │   └── read-more
    │       ├── resource1.md
    │       └── resource2.md
    ├── easy
    │   ├── easy1.md
    │   └── easy2.md
    ├── tutorial-end.md
    ├── tutorial-intro.md
    └── tutorial-medium.md
```

并假设每个文档的 ID 就是它的文件名。如果您像这样定义一个自动生成的侧边栏：

```js title="sidebars.js"
export default {
  mySidebar: [
    'intro',
    {
      type: 'category',
      label: '教程',
      items: [
        'tutorial-intro',
        // highlight-start
        {
          type: 'autogenerated',
          dirName: 'tutorials/easy', // 从 docs/tutorials/easy 生成侧边栏切片
        },
        // highlight-end
        'tutorial-medium',
        // highlight-start
        {
          type: 'autogenerated',
          dirName: 'tutorials/advanced', // 从 docs/tutorials/advanced 生成侧边栏切片
        },
        // highlight-end
        'tutorial-end',
      ],
    },
    // highlight-start
    {
      type: 'autogenerated',
      dirName: 'api', // 从 docs/api 生成侧边栏切片
    },
    // highlight-end
    {
      type: 'category',
      label: '社区',
      items: ['team', 'chat'],
    },
  ],
};
```

它将被解析为：

```js title="sidebars.js"
export default {
  mySidebar: [
    'intro',
    {
      type: 'category',
      label: '教程',
      items: [
        'tutorial-intro',
        // highlight-start
        // docs/tutorials/easy 中的两个文件
        'easy1',
        'easy2',
        // highlight-end
        'tutorial-medium',
        // highlight-start
        // docs/tutorials/advanced 中的两个文件和一个文件夹
        'advanced1',
        'advanced2',
        {
          type: 'category',
          label: 'read-more',
          items: ['resource1', 'resource2'],
        },
        // highlight-end
        'tutorial-end',
      ],
    },
    // highlight-start
    // docs/api 中的两个文件夹
    {
      type: 'category',
      label: 'product1-api',
      items: ['api'],
    },
    {
      type: 'category',
      label: 'product2-api',
      items: ['basic-api', 'pro-api'],
    },
    // highlight-end
    {
      type: 'category',
      label: '社区',
      items: ['team', 'chat'],
    },
  ],
};
```

注意自动生成的源目录本身如何不成为分类：只有它们包含的项目才会。这就是我们所说的“侧边栏切片”。

</details>

## 分类索引约定 {#category-index-convention}

Docusaurus 可以自动将一个分类链接到其索引文档。

分类索引文档是遵循以下文件名约定之一的文档：

- 命名为 `index`（不区分大小写）：`docs/Guides/index.md`
- 命名为 `README`（不区分大小写）：`docs/Guides/README.mdx`
- 与父文件夹同名：`docs/Guides/Guides.md`

这等同于使用带有[文档链接](items.mdx#category-doc-link)的分类：

```js title="sidebars.js"
export default {
  docs: [
    // highlight-start
    {
      type: 'category',
      label: '指南',
      link: {type: 'doc', id: 'Guides/index'},
      items: [],
    },
    // highlight-end
  ],
};
```

:::tip

将您的介绍性文档命名为 `README.md` 会在使用 GitHub 界面浏览文件夹时显示它，而使用 `index.md` 则使行为更符合 HTML 文件的服务方式。

:::

:::tip

如果一个文件夹只有一个索引页，它将被转换为一个链接而不是一个分类。这对于**资源共置**很有用：

```
some-doc
├── index.md
├── img1.png
└── img2.png
```

:::

<details>

<summary>自定义分类索引匹配</summary>

可以退出任何分类索引约定，或定义更多约定。您可以通过 [`sidebarItemsGenerator`](#customize-the-sidebar-items-generator) 回调注入您自己的 `isCategoryIndex` 匹配器。例如，您还可以选择 `intro` 作为另一个有资格自动成为分类索引的文件名。

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        async sidebarItemsGenerator({
          ...args,
          isCategoryIndex: defaultCategoryIndexMatcher, // 默认匹配器实现，如下所示
          defaultSidebarItemsGenerator,
        }) {
          return defaultSidebarItemsGenerator({
            ...args,
            // highlight-start
            isCategoryIndex(doc) {
              return (
                // 除默认的外，还选择 intro.md
                doc.fileName.toLowerCase() === 'intro' ||
                defaultCategoryIndexMatcher(doc)
              );
            },
            // highlight-end
          });
        },
      },
    ],
  ],
};
```

或者选择没有任何分类索引约定。

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        async sidebarItemsGenerator({
          ...args,
          isCategoryIndex: defaultCategoryIndexMatcher, // 默认匹配器实现，如下所示
          defaultSidebarItemsGenerator,
        }) {
          return defaultSidebarItemsGenerator({
            ...args,
            // highlight-start
            isCategoryIndex() {
              // 没有文档会被自动选为分类索引
              return false;
            },
            // highlight-end
          });
        },
      },
    ],
  ],
};
```

`isCategoryIndex` 匹配器将提供三个字段：

- `fileName`，文件的名称，不含扩展名并保留大小写
- `directories`，目录名称列表，_从最低级到最高级_，相对于 docs 根目录
- `extension`，文件的扩展名，带一个前导点。

例如，对于位于 `guides/sidebar/autogenerated.md` 的文档文件，匹配器接收到的 props 是

```js
const props = {
  fileName: 'autogenerated',
  directories: ['sidebar', 'guides'],
  extension: '.md',
};
```

默认实现是：

```js
function isCategoryIndex({fileName, directories}) {
  const eligibleDocIndexNames = [
    'index',
    'readme',
    directories[0].toLowerCase(),
  ];
  return eligibleDocIndexNames.includes(fileName.toLowerCase());
}
```

</details>

## 自动生成的侧边栏元数据 {#autogenerated-sidebar-metadata}

对于手写的侧边栏定义，您将通过 `sidebars.js` 为侧边栏项目提供元数据；对于自动生成的，Docusaurus 将从项目的相应文件中读取它们。此外，您可能希望调整每个项目的相对位置，因为默认情况下，侧边栏切片中的项目将按**字母顺序**（使用文件和文件夹名称）生成。

### 文档项目元数据 {#doc-item-metadata}

`label`、`className` 和 `customProps` 属性在 front matter 中分别声明为 `sidebar_label`、`sidebar_class_name` 和 `sidebar_custom_props`。位置可以通过 `sidebar_position` front matter 以同样的方式指定。

```md title="docs/tutorials/tutorial-easy.md"
---
# highlight-start
sidebar_position: 2
sidebar_label: 简单
sidebar_class_name: green
# highlight-end
---

# 简单教程

这是简单教程！
```

### 分类项目元数据 {#category-item-metadata}

在相应的文件夹中添加一个 `_category_.json` 或 `_category_.yml` 文件。您可以指定任何分类元数据以及 `position` 元数据。`label`、`className`、`position` 和 `customProps` 将默认为分类链接文档的相应值（如果存在）。

<Tabs>
<TabItem value="JSON">

```json title="docs/tutorials/_category_.json"
{
  "position": 2.5,
  "label": "教程",
  "collapsible": true,
  "collapsed": false,
  "className": "red",
  "link": {
    "type": "generated-index",
    "title": "教程概述"
  },
  "customProps": {
    "description": "此描述可用于 swizzled 的 DocCard"
  }
}
```

</TabItem>
<TabItem value="YAML">

```yml title="docs/tutorials/_category_.yml"
position: 2.5 # 支持浮点数位置
label: '教程'
collapsible: true # 使分类可折叠
collapsed: false # 默认保持分类展开
className: red
link:
  type: generated-index
  title: 教程概述
customProps:
  description: 此描述可用于 swizzled 的 DocCard
```

</TabItem>
</Tabs>

:::info

如果明确指定了 `link`，Docusaurus 将不应用任何[默认约定](#category-index-convention)。

文档链接可以相对指定，例如，如果分类是使用 `guides` 目录生成的，`"link": {"type": "doc", "id": "intro"}` 将被解析为 ID `guides/intro`，仅在不存在具有前一个 ID 的文档时才回退到 `intro`。

您也可以使用 `link: null` 来退出默认约定，不生成任何分类索引页。

:::

:::info

位置元数据仅在**侧边栏切片内**使用：Docusaurus 不会重新排序您侧边栏的其他项目。

:::

## 使用数字前缀 {#using-number-prefixes}

对自动生成的侧边栏进行排序的一个简单方法是给文档和文件夹加上数字前缀，这也使得它们在按文件名排序时在文件系统中以相同的顺序出现：

```bash
docs
├── 01-简介.md
├── 02-简单教程
│   ├── 01-第一部分.md
│   ├── 02-第二部分.md
│   └── 03-结束.md
├── 03-高级教程
│   ├── 01-第一部分.md
│   ├── 02-第二部分.md
│   ├── 03-第三部分.md
│   └── 04-结束.md
└── 04-结束.md
```

为了**更容易采用**，Docusaurus 支持**多种数字前缀模式**。

默认情况下，Docusaurus 将从文档 ID、标题、标签和 URL 路径中**移除数字前缀**。

:::warning

**优先使用[附加元数据](#autogenerated-sidebar-metadata)**。

更新数字前缀可能很麻烦，因为它可能需要**更新多个现有的 Markdown 链接**：

```diff title="docs/02-Tutorial Easy/01-First Part.md"
- 查看[教程结束](../04-End.mdx)；
+ 查看[教程结束](../05-End.mdx)；
```

:::

## 自定义侧边栏项目生成器 {#customize-the-sidebar-items-generator}

您可以在 docs 插件（或 preset）配置中提供一个自定义的 `sidebarItemsGenerator` 函数：

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        // highlight-start
        async sidebarItemsGenerator({
          defaultSidebarItemsGenerator,
          numberPrefixParser,
          item,
          version,
          docs,
          categoriesMetadata,
          isCategoryIndex,
        }) {
          // 示例：返回一个硬编码的静态侧边栏项目列表
          return [
            {type: 'doc', id: 'doc1'},
            {type: 'doc', id: 'doc2'},
          ];
        },
        // highlight-end
      },
    ],
  ],
};
```

:::tip

**重用和增强默认生成器**而不是从头开始编写生成器：[我们提供的默认生成器](https://github.com/facebook/docusaurus/blob/main/packages/docusaurus-plugin-content-docs/src/sidebars/generator.ts)有 250 行长。

**根据您的用例添加、更新、筛选、重新排序**侧边栏项目：

```js title="docusaurus.config.js"
// highlight-start
// 反转侧边栏项目顺序（包括嵌套的分类项目）
function reverseSidebarItems(items) {
  // 反转分类中的项目
  const result = items.map((item) => {
    if (item.type === 'category') {
      return {...item, items: reverseSidebarItems(item.items)};
    }
    return item;
  });
  // 反转当前级别的项目
  result.reverse();
  return result;
}
// highlight-end

export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        // highlight-start
        async sidebarItemsGenerator({defaultSidebarItemsGenerator, ...args}) {
          const sidebarItems = await defaultSidebarItemsGenerator(args);
          return reverseSidebarItems(sidebarItems);
        },
        // highlight-end
      },
    ],
  ],
};
```

:::
