---
title: 插件方法参考
sidebar_label: 介绍
---

# 插件方法参考

:::warning

本节仍在施工中。锚点链接甚至 URL 都不能保证稳定。

:::

插件 API 由主题和插件共享——主题的加载方式与插件完全相同。

## 插件模块 {#plugin-module}

每个插件都作为模块导入。该模块应具有以下成员：

- 一个**默认导出**：插件的构造函数。
- **命名导出**：在插件初始化之前调用的[静态方法](./static-methods.mdx)。

## 插件构造函数 {#plugin-constructor}

插件模块的默认导出是一个构造函数，其签名为 `(context: LoadContext, options: PluginOptions) => Plugin | Promise<Plugin>`。

### `context` {#context}

`context` 与插件无关，同一对象将被传递给用于 Docusaurus 网站的所有插件。`context` 对象包含以下字段：

```ts
type LoadContext = {
  siteDir: string;
  generatedFilesDir: string;
  siteConfig: DocusaurusConfig;
  outDir: string;
  baseUrl: string;
};
```

### `options` {#options}

`options` 是[使用插件时的第二个可选参数](../../using-plugins.mdx#configuring-plugins)。`options` 是特定于插件的，由用户在 `docusaurus.config.js` 中使用它们时指定。如果导出了 [`validateOptions`](./static-methods.mdx#validateOptions) 函数，`options` 将被预先验证和规范化。

或者，如果 preset 包含该插件，则 preset 将负责将正确的选项传递给插件。由各个插件自行定义其接受的选项。

## 示例 {#example}

这是一个假定的插件实现的心智模型。

```js
// 一个返回对象的 JavaScript 函数。
// `context` 由 Docusaurus 提供。示例：可以从 context 访问 siteConfig。
// `opts` 是用户定义的选项。
export default async function myPlugin(context, opts) {
  return {
    // 一个强制字段，用作缓存目录的命名空间
    // 每个插件的中间数据。
    // 如果你正在编写自己的本地插件，你会希望它
    // 是唯一的，以免与导入的插件发生潜在冲突。
    // 一个好方法是在其中添加你自己的项目名称。
    name: 'docusaurus-my-project-cool-plugin',

    async loadContent() {
      // loadContent 钩子在 siteConfig 和 env 加载后执行。
      // 你可以返回一个将传递给 contentLoaded 钩子的 JavaScript 对象。
    },

    async contentLoaded({content, actions}) {
      // contentLoaded 钩子在 loadContent 钩子完成后执行。
      // `actions` 是 Docusaurus 提供的一组功能性 API（例如 addRoute）
    },

    async postBuild(props) {
      // 在 docusaurus <build> 完成后。
    },

    // TODO
    async postStart(props) {
      // docusaurus <start> 完成
    },

    // TODO
    afterDevServer(app, server) {
      // https://webpack.js.org/configuration/dev-server/#devserverbefore
    },

    // TODO
    beforeDevServer(app, server) {
      // https://webpack.js.org/configuration/dev-server/#devserverafter
    },

    configureWebpack(config, isServer, utils, content) {
      // 修改内部 webpack 配置。如果返回的值是一个对象，它
      // 将使用 webpack-merge 合并到最终配置中；
      // 如果返回的值是一个函数，它将接收配置作为第一个参数，isServer 标志作为第二个参数。
    },

    getPathsToWatch() {
      // 要监视的路径。
    },

    getThemePath() {
      // 返回可以找到主题组件的目录路径。
    },

    getClientModules() {
      // 返回要导入的模块的路径数组
      // 在客户端包中。这些模块在 React 渲染初始 UI 之前
      // 就已全局导入。
    },

    extendCli(cli) {
      // 注册一个额外的命令来增强 Docusaurus 的 CLI
    },

    injectHtmlTags({content}) {
      // 注入 head 和/或 body HTML 标签。
    },

    async getTranslationFiles({content}) {
      // 返回翻译文件
    },



    translateContent({content, translationFiles}) {
      // 在此处翻译插件内容
    },

    translateThemeConfig({themeConfig, translationFiles}) {
      // 在此处翻译网站 themeConfig
    },

    async getDefaultCodeTranslationMessages() {
      // 在此处返回默认主题翻译
    },
  };
}

export function validateOptions({options, validate}) {
  const validatedOptions = validate(myValidationSchema, options);
  return validatedOptions;
}

export function validateThemeConfig({themeConfig, validate}) {
  const validatedThemeConfig = validate(myValidationSchema, options);
  return validatedThemeConfig;
}
```
